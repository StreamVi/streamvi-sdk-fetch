/* tslint:disable */
/* eslint-disable */
/**
 * StreamVi Backend
 * API
 *
 * The version of the OpenAPI document: 3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ErrorResponse,
  NotifyHistorySiteResponse,
  NotifyHistoryStatusUserResponse,
  PaginatedResponseOfNotifyHistorySiteResponse,
  SiteMarkReadHistoryRequest,
  SiteMarkReadHistoryResponse,
  SuccessResponse,
} from '../models/index';
import {
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    NotifyHistorySiteResponseFromJSON,
    NotifyHistorySiteResponseToJSON,
    NotifyHistoryStatusUserResponseFromJSON,
    NotifyHistoryStatusUserResponseToJSON,
    PaginatedResponseOfNotifyHistorySiteResponseFromJSON,
    PaginatedResponseOfNotifyHistorySiteResponseToJSON,
    SiteMarkReadHistoryRequestFromJSON,
    SiteMarkReadHistoryRequestToJSON,
    SiteMarkReadHistoryResponseFromJSON,
    SiteMarkReadHistoryResponseToJSON,
    SuccessResponseFromJSON,
    SuccessResponseToJSON,
} from '../models/index';

export interface NotifyHistoryGetListMyV1Request {
    language: NotifyHistoryGetListMyV1LanguageEnum;
    v?: NotifyHistoryGetListMyV1VEnum;
    limit?: number;
    offset?: number;
    project_id?: number;
    name?: NotifyHistoryGetListMyV1NameEnum;
    channel?: NotifyHistoryGetListMyV1ChannelEnum;
    date_from?: Date;
    date_to?: Date;
    status_read?: NotifyHistoryGetListMyV1StatusReadEnum;
}

export interface NotifyHistoryGetStatusMyV1Request {
    language: NotifyHistoryGetStatusMyV1LanguageEnum;
    v?: NotifyHistoryGetStatusMyV1VEnum;
}

export interface NotifyHistoryGetV1Request {
    _id: string;
    v?: NotifyHistoryGetV1VEnum;
}

export interface NotifyHistoryMarkOfReadV1Request {
    language: NotifyHistoryMarkOfReadV1LanguageEnum;
    SiteMarkReadHistoryRequest: SiteMarkReadHistoryRequest;
    v?: NotifyHistoryMarkOfReadV1VEnum;
}

export interface NotifyHistoryRunActionV1Request {
    notify_history_id: string;
    action_name: string;
    group_id: string;
    v?: NotifyHistoryRunActionV1VEnum;
}

/**
 * NotifyHistoryApi - interface
 * 
 * @export
 * @interface NotifyHistoryApiInterface
 */
export interface NotifyHistoryApiInterface {
    /**
     * 
     * @summary Get list of my notifications
     * @param {'ru' | 'en' | 'cn'} language Current language
     * @param {'1' | '2' | '3'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {number} [project_id] Project id
     * @param {'high_bitrate' | 'request_access_channel' | 'request_access_project' | 'promocode_test' | 'stream_test' | 'plan_restream_expires' | 'plan_restream_expired' | 'plan_restream_renewed' | 'plan_transcoder_expires' | 'plan_transcoder_expired' | 'plan_transcoder_renewed' | 'plan_storage_expires' | 'plan_storage_expired' | 'plan_storage_renewed' | 'broadcast_unsupported_codec' | 'broadcast_unsupported_codec_screen' | 'broadcast_bitrate_exceeded_screen' | 'rtmp_connect_old_server_screen' | 'broadcast_not_audio' | 'broadcast_bitrate_exceeded' | 'broadcast_started' | 'broadcast_stopped' | 'restream_check_twitch_bitrate_1' | 'api_pause_start' | 'api_pause_end' | 'api_wait_edit' | 'api_restream_start' | 'api_restream_stop' | 'api_drop_broadcast' | 'api_drop_broadcast_remove_company' | 'api_drop_broadcast_update_key' | 'publisher_disconnected' | 'publisher_connected' | 'publisher_initializing' | 'publisher_close' | 'broadcast_connected_start' | 'broadcast_connected_end' | 'broadcast_connecting_stream' | 'broadcast_started_new_stream' | 'broadcast_connecting_lost' | 'broadcast_video_lost_start' | 'broadcast_video_lost_end' | 'broadcast_video_pause_start' | 'broadcast_video_pause_end' | 'broadcast_init_restream' | 'start_stream' | 'create_reader' | 'start_channel' | 'stop_channel' | 'stop_stream_video_timeout' | 'stop_stream_no_start_video' | 'stop_stream' | 'delete_reader' | 'transcoder_start' | 'transcoder_stop' | 'start_channel_failed' | 'start_channel_success' | 'api_channel_initializing_start' | 'api_channel_initializing_failed' | 'api_channel_initializing_success' | 'channel_api_update_settings_success' | 'channel_api_update_settings_error' | 'channel_api_update_playlist_success' | 'channel_api_update_playlist_error' | 'channel_api_update_chat_error' | 'channel_api_stream_key_success' | 'channel_api_stream_key_error' | 'channel_api_auto_stop_disable_success' | 'channel_api_auto_stop_disable_error' | 'channel_api_unbinding_stream_key_error' | 'channel_api_create_broadcast_success' | 'channel_api_create_broadcast_error' | 'channel_api_set_planned_success' | 'channel_api_set_planned_error' | 'channel_api_set_thumbnail_success' | 'channel_api_set_thumbnail_error' | 'channel_token_error' | 'channel_api_group_failed' | 'no_audio_reader' | 'restream_check_twitch_bitrate_2' | 'transcoder_support_error_screen' | 'transcoder_tariff_end_screen' | 'transcoder_count_flow_screen' | 'transcoder_resolution_screen' | 'stream_key_banned' | 'broadcast_change_codec' | 'broadcast_change_region' | 'video_upload_error' | 'stop_channel_error' | 'broadcast_user_action_stop'} [name] Name
     * @param {'telegram' | 'cabinet' | 'mobile'} [channel] Channel
     * @param {Date} [date_from] Date from
     * @param {Date} [date_to] Date to
     * @param {'unread' | 'read'} [status_read] Status read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryGetListMyV1Raw(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedResponseOfNotifyHistorySiteResponse>>;

    /**
     * Get list of my notifications
     */
    notifyHistoryGetListMyV1(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedResponseOfNotifyHistorySiteResponse>;

    /**
     * 
     * @summary Get my status unread message for user
     * @param {'ru' | 'en' | 'cn'} language Current language
     * @param {'1' | '2' | '3'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryGetStatusMyV1Raw(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistoryStatusUserResponse>>;

    /**
     * Get my status unread message for user
     */
    notifyHistoryGetStatusMyV1(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistoryStatusUserResponse>;

    /**
     * 
     * @summary Get my NotifyHistory item by id
     * @param {string} _id Id of page in mongodb
     * @param {'1'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryGetV1Raw(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>>;

    /**
     * Get my NotifyHistory item by id
     */
    notifyHistoryGetV1(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse>;

    /**
     * 
     * @summary Set notification in cabinet as read
     * @param {'ru' | 'en' | 'cn'} language Current language
     * @param {SiteMarkReadHistoryRequest} SiteMarkReadHistoryRequest 
     * @param {'1' | '2' | '3'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryMarkOfReadV1Raw(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteMarkReadHistoryResponse>>;

    /**
     * Set notification in cabinet as read
     */
    notifyHistoryMarkOfReadV1(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteMarkReadHistoryResponse>;

    /**
     * 
     * @summary Run action in my notify item
     * @param {string} notify_history_id Id of page in mongodb
     * @param {string} action_name Action name
     * @param {string} group_id Group id
     * @param {'1'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryRunActionV1Raw(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>>;

    /**
     * Run action in my notify item
     */
    notifyHistoryRunActionV1(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse>;

    /**
     * 
     * @summary Set all notification in cabinet as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistorySetAllCabinetReadV1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponse>>;

    /**
     * Set all notification in cabinet as read
     */
    notifyHistorySetAllCabinetReadV1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponse>;

}

/**
 * 
 */
export class NotifyHistoryApi extends runtime.BaseAPI implements NotifyHistoryApiInterface {

    /**
     * Get list of my notifications
     */
    async notifyHistoryGetListMyV1Raw(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedResponseOfNotifyHistorySiteResponse>> {
        if (requestParameters['language'] == null) {
            throw new runtime.RequiredError(
                'language',
                'Required parameter "language" was null or undefined when calling notifyHistoryGetListMyV1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['v'] != null) {
            queryParameters['v'] = requestParameters['v'];
        } else {
            queryParameters['v'] = '1';
        }

        if (requestParameters['language'] != null) {
            queryParameters['language'] = requestParameters['language'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['project_id'] != null) {
            queryParameters['project_id'] = requestParameters['project_id'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['channel'] != null) {
            queryParameters['channel'] = requestParameters['channel'];
        }

        if (requestParameters['date_from'] != null) {
            queryParameters['date_from'] = (requestParameters['date_from'] as any).toISOString();
        }

        if (requestParameters['date_to'] != null) {
            queryParameters['date_to'] = (requestParameters['date_to'] as any).toISOString();
        }

        if (requestParameters['status_read'] != null) {
            queryParameters['status_read'] = requestParameters['status_read'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/method/notify_history/list`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedResponseOfNotifyHistorySiteResponseFromJSON(jsonValue));
    }

    /**
     * Get list of my notifications
     */
    async notifyHistoryGetListMyV1(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedResponseOfNotifyHistorySiteResponse> {
        const response = await this.notifyHistoryGetListMyV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get my status unread message for user
     */
    async notifyHistoryGetStatusMyV1Raw(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistoryStatusUserResponse>> {
        if (requestParameters['language'] == null) {
            throw new runtime.RequiredError(
                'language',
                'Required parameter "language" was null or undefined when calling notifyHistoryGetStatusMyV1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['v'] != null) {
            queryParameters['v'] = requestParameters['v'];
        } else {
            queryParameters['v'] = '1';
        }

        if (requestParameters['language'] != null) {
            queryParameters['language'] = requestParameters['language'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/method/notify_history/get_status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NotifyHistoryStatusUserResponseFromJSON(jsonValue));
    }

    /**
     * Get my status unread message for user
     */
    async notifyHistoryGetStatusMyV1(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistoryStatusUserResponse> {
        const response = await this.notifyHistoryGetStatusMyV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get my NotifyHistory item by id
     */
    async notifyHistoryGetV1Raw(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>> {
        if (requestParameters['_id'] == null) {
            throw new runtime.RequiredError(
                '_id',
                'Required parameter "_id" was null or undefined when calling notifyHistoryGetV1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['v'] != null) {
            queryParameters['v'] = requestParameters['v'];
        } else {
            queryParameters['v'] = '1';
        }

        if (requestParameters['_id'] != null) {
            queryParameters['_id'] = requestParameters['_id'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/method/notify_history/get`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NotifyHistorySiteResponseFromJSON(jsonValue));
    }

    /**
     * Get my NotifyHistory item by id
     */
    async notifyHistoryGetV1(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse> {
        const response = await this.notifyHistoryGetV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set notification in cabinet as read
     */
    async notifyHistoryMarkOfReadV1Raw(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteMarkReadHistoryResponse>> {
        if (requestParameters['language'] == null) {
            throw new runtime.RequiredError(
                'language',
                'Required parameter "language" was null or undefined when calling notifyHistoryMarkOfReadV1().'
            );
        }

        if (requestParameters['SiteMarkReadHistoryRequest'] == null) {
            throw new runtime.RequiredError(
                'SiteMarkReadHistoryRequest',
                'Required parameter "SiteMarkReadHistoryRequest" was null or undefined when calling notifyHistoryMarkOfReadV1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['v'] != null) {
            queryParameters['v'] = requestParameters['v'];
        } else {
            queryParameters['v'] = '1';
        }

        if (requestParameters['language'] != null) {
            queryParameters['language'] = requestParameters['language'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/method/notify_history/read`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SiteMarkReadHistoryRequestToJSON(requestParameters['SiteMarkReadHistoryRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteMarkReadHistoryResponseFromJSON(jsonValue));
    }

    /**
     * Set notification in cabinet as read
     */
    async notifyHistoryMarkOfReadV1(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteMarkReadHistoryResponse> {
        const response = await this.notifyHistoryMarkOfReadV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Run action in my notify item
     */
    async notifyHistoryRunActionV1Raw(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>> {
        if (requestParameters['notify_history_id'] == null) {
            throw new runtime.RequiredError(
                'notify_history_id',
                'Required parameter "notify_history_id" was null or undefined when calling notifyHistoryRunActionV1().'
            );
        }

        if (requestParameters['action_name'] == null) {
            throw new runtime.RequiredError(
                'action_name',
                'Required parameter "action_name" was null or undefined when calling notifyHistoryRunActionV1().'
            );
        }

        if (requestParameters['group_id'] == null) {
            throw new runtime.RequiredError(
                'group_id',
                'Required parameter "group_id" was null or undefined when calling notifyHistoryRunActionV1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['v'] != null) {
            queryParameters['v'] = requestParameters['v'];
        } else {
            queryParameters['v'] = '1';
        }

        if (requestParameters['notify_history_id'] != null) {
            queryParameters['notify_history_id'] = requestParameters['notify_history_id'];
        }

        if (requestParameters['action_name'] != null) {
            queryParameters['action_name'] = requestParameters['action_name'];
        }

        if (requestParameters['group_id'] != null) {
            queryParameters['group_id'] = requestParameters['group_id'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/method/notify_history/run_action`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NotifyHistorySiteResponseFromJSON(jsonValue));
    }

    /**
     * Run action in my notify item
     */
    async notifyHistoryRunActionV1(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse> {
        const response = await this.notifyHistoryRunActionV1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set all notification in cabinet as read
     */
    async notifyHistorySetAllCabinetReadV1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/method/notify_history/set_all_cabinet_read`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseFromJSON(jsonValue));
    }

    /**
     * Set all notification in cabinet as read
     */
    async notifyHistorySetAllCabinetReadV1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponse> {
        const response = await this.notifyHistorySetAllCabinetReadV1Raw(initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const NotifyHistoryGetListMyV1LanguageEnum = {
    ru: 'ru',
    en: 'en',
    cn: 'cn'
} as const;
export type NotifyHistoryGetListMyV1LanguageEnum = typeof NotifyHistoryGetListMyV1LanguageEnum[keyof typeof NotifyHistoryGetListMyV1LanguageEnum];
/**
 * @export
 */
export const NotifyHistoryGetListMyV1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type NotifyHistoryGetListMyV1VEnum = typeof NotifyHistoryGetListMyV1VEnum[keyof typeof NotifyHistoryGetListMyV1VEnum];
/**
 * @export
 */
export const NotifyHistoryGetListMyV1NameEnum = {
    high_bitrate: 'high_bitrate',
    request_access_channel: 'request_access_channel',
    request_access_project: 'request_access_project',
    promocode_test: 'promocode_test',
    stream_test: 'stream_test',
    plan_restream_expires: 'plan_restream_expires',
    plan_restream_expired: 'plan_restream_expired',
    plan_restream_renewed: 'plan_restream_renewed',
    plan_transcoder_expires: 'plan_transcoder_expires',
    plan_transcoder_expired: 'plan_transcoder_expired',
    plan_transcoder_renewed: 'plan_transcoder_renewed',
    plan_storage_expires: 'plan_storage_expires',
    plan_storage_expired: 'plan_storage_expired',
    plan_storage_renewed: 'plan_storage_renewed',
    broadcast_unsupported_codec: 'broadcast_unsupported_codec',
    broadcast_unsupported_codec_screen: 'broadcast_unsupported_codec_screen',
    broadcast_bitrate_exceeded_screen: 'broadcast_bitrate_exceeded_screen',
    rtmp_connect_old_server_screen: 'rtmp_connect_old_server_screen',
    broadcast_not_audio: 'broadcast_not_audio',
    broadcast_bitrate_exceeded: 'broadcast_bitrate_exceeded',
    broadcast_started: 'broadcast_started',
    broadcast_stopped: 'broadcast_stopped',
    restream_check_twitch_bitrate_1: 'restream_check_twitch_bitrate_1',
    api_pause_start: 'api_pause_start',
    api_pause_end: 'api_pause_end',
    api_wait_edit: 'api_wait_edit',
    api_restream_start: 'api_restream_start',
    api_restream_stop: 'api_restream_stop',
    api_drop_broadcast: 'api_drop_broadcast',
    api_drop_broadcast_remove_company: 'api_drop_broadcast_remove_company',
    api_drop_broadcast_update_key: 'api_drop_broadcast_update_key',
    publisher_disconnected: 'publisher_disconnected',
    publisher_connected: 'publisher_connected',
    publisher_initializing: 'publisher_initializing',
    publisher_close: 'publisher_close',
    broadcast_connected_start: 'broadcast_connected_start',
    broadcast_connected_end: 'broadcast_connected_end',
    broadcast_connecting_stream: 'broadcast_connecting_stream',
    broadcast_started_new_stream: 'broadcast_started_new_stream',
    broadcast_connecting_lost: 'broadcast_connecting_lost',
    broadcast_video_lost_start: 'broadcast_video_lost_start',
    broadcast_video_lost_end: 'broadcast_video_lost_end',
    broadcast_video_pause_start: 'broadcast_video_pause_start',
    broadcast_video_pause_end: 'broadcast_video_pause_end',
    broadcast_init_restream: 'broadcast_init_restream',
    start_stream: 'start_stream',
    create_reader: 'create_reader',
    start_channel: 'start_channel',
    stop_channel: 'stop_channel',
    stop_stream_video_timeout: 'stop_stream_video_timeout',
    stop_stream_no_start_video: 'stop_stream_no_start_video',
    stop_stream: 'stop_stream',
    delete_reader: 'delete_reader',
    transcoder_start: 'transcoder_start',
    transcoder_stop: 'transcoder_stop',
    start_channel_failed: 'start_channel_failed',
    start_channel_success: 'start_channel_success',
    api_channel_initializing_start: 'api_channel_initializing_start',
    api_channel_initializing_failed: 'api_channel_initializing_failed',
    api_channel_initializing_success: 'api_channel_initializing_success',
    channel_api_update_settings_success: 'channel_api_update_settings_success',
    channel_api_update_settings_error: 'channel_api_update_settings_error',
    channel_api_update_playlist_success: 'channel_api_update_playlist_success',
    channel_api_update_playlist_error: 'channel_api_update_playlist_error',
    channel_api_update_chat_error: 'channel_api_update_chat_error',
    channel_api_stream_key_success: 'channel_api_stream_key_success',
    channel_api_stream_key_error: 'channel_api_stream_key_error',
    channel_api_auto_stop_disable_success: 'channel_api_auto_stop_disable_success',
    channel_api_auto_stop_disable_error: 'channel_api_auto_stop_disable_error',
    channel_api_unbinding_stream_key_error: 'channel_api_unbinding_stream_key_error',
    channel_api_create_broadcast_success: 'channel_api_create_broadcast_success',
    channel_api_create_broadcast_error: 'channel_api_create_broadcast_error',
    channel_api_set_planned_success: 'channel_api_set_planned_success',
    channel_api_set_planned_error: 'channel_api_set_planned_error',
    channel_api_set_thumbnail_success: 'channel_api_set_thumbnail_success',
    channel_api_set_thumbnail_error: 'channel_api_set_thumbnail_error',
    channel_token_error: 'channel_token_error',
    channel_api_group_failed: 'channel_api_group_failed',
    no_audio_reader: 'no_audio_reader',
    restream_check_twitch_bitrate_2: 'restream_check_twitch_bitrate_2',
    transcoder_support_error_screen: 'transcoder_support_error_screen',
    transcoder_tariff_end_screen: 'transcoder_tariff_end_screen',
    transcoder_count_flow_screen: 'transcoder_count_flow_screen',
    transcoder_resolution_screen: 'transcoder_resolution_screen',
    stream_key_banned: 'stream_key_banned',
    broadcast_change_codec: 'broadcast_change_codec',
    broadcast_change_region: 'broadcast_change_region',
    video_upload_error: 'video_upload_error',
    stop_channel_error: 'stop_channel_error',
    broadcast_user_action_stop: 'broadcast_user_action_stop'
} as const;
export type NotifyHistoryGetListMyV1NameEnum = typeof NotifyHistoryGetListMyV1NameEnum[keyof typeof NotifyHistoryGetListMyV1NameEnum];
/**
 * @export
 */
export const NotifyHistoryGetListMyV1ChannelEnum = {
    telegram: 'telegram',
    cabinet: 'cabinet',
    mobile: 'mobile'
} as const;
export type NotifyHistoryGetListMyV1ChannelEnum = typeof NotifyHistoryGetListMyV1ChannelEnum[keyof typeof NotifyHistoryGetListMyV1ChannelEnum];
/**
 * @export
 */
export const NotifyHistoryGetListMyV1StatusReadEnum = {
    unread: 'unread',
    read: 'read'
} as const;
export type NotifyHistoryGetListMyV1StatusReadEnum = typeof NotifyHistoryGetListMyV1StatusReadEnum[keyof typeof NotifyHistoryGetListMyV1StatusReadEnum];
/**
 * @export
 */
export const NotifyHistoryGetStatusMyV1LanguageEnum = {
    ru: 'ru',
    en: 'en',
    cn: 'cn'
} as const;
export type NotifyHistoryGetStatusMyV1LanguageEnum = typeof NotifyHistoryGetStatusMyV1LanguageEnum[keyof typeof NotifyHistoryGetStatusMyV1LanguageEnum];
/**
 * @export
 */
export const NotifyHistoryGetStatusMyV1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type NotifyHistoryGetStatusMyV1VEnum = typeof NotifyHistoryGetStatusMyV1VEnum[keyof typeof NotifyHistoryGetStatusMyV1VEnum];
/**
 * @export
 */
export const NotifyHistoryGetV1VEnum = {
    _1: '1'
} as const;
export type NotifyHistoryGetV1VEnum = typeof NotifyHistoryGetV1VEnum[keyof typeof NotifyHistoryGetV1VEnum];
/**
 * @export
 */
export const NotifyHistoryMarkOfReadV1LanguageEnum = {
    ru: 'ru',
    en: 'en',
    cn: 'cn'
} as const;
export type NotifyHistoryMarkOfReadV1LanguageEnum = typeof NotifyHistoryMarkOfReadV1LanguageEnum[keyof typeof NotifyHistoryMarkOfReadV1LanguageEnum];
/**
 * @export
 */
export const NotifyHistoryMarkOfReadV1VEnum = {
    _1: '1',
    _2: '2',
    _3: '3'
} as const;
export type NotifyHistoryMarkOfReadV1VEnum = typeof NotifyHistoryMarkOfReadV1VEnum[keyof typeof NotifyHistoryMarkOfReadV1VEnum];
/**
 * @export
 */
export const NotifyHistoryRunActionV1VEnum = {
    _1: '1'
} as const;
export type NotifyHistoryRunActionV1VEnum = typeof NotifyHistoryRunActionV1VEnum[keyof typeof NotifyHistoryRunActionV1VEnum];
