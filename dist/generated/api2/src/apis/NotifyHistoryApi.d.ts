/**
 * StreamVi Backend
 * API
 *
 * The version of the OpenAPI document: 3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import * as runtime from '../runtime';
import type { NotifyHistorySiteResponse, NotifyHistoryStatusUserResponse, PaginatedResponseOfNotifyHistorySiteResponse, SiteMarkReadHistoryRequest, SiteMarkReadHistoryResponse, SuccessResponse } from '../models/index';
export interface NotifyHistoryGetListMyV1Request {
    language: NotifyHistoryGetListMyV1LanguageEnum;
    v?: NotifyHistoryGetListMyV1VEnum;
    limit?: number;
    offset?: number;
    project_id?: number;
    name?: NotifyHistoryGetListMyV1NameEnum;
    channel?: NotifyHistoryGetListMyV1ChannelEnum;
    date_from?: Date;
    date_to?: Date;
    status_read?: NotifyHistoryGetListMyV1StatusReadEnum;
}
export interface NotifyHistoryGetStatusMyV1Request {
    language: NotifyHistoryGetStatusMyV1LanguageEnum;
    v?: NotifyHistoryGetStatusMyV1VEnum;
}
export interface NotifyHistoryGetV1Request {
    _id: string;
    v?: NotifyHistoryGetV1VEnum;
}
export interface NotifyHistoryMarkOfReadV1Request {
    language: NotifyHistoryMarkOfReadV1LanguageEnum;
    SiteMarkReadHistoryRequest: SiteMarkReadHistoryRequest;
    v?: NotifyHistoryMarkOfReadV1VEnum;
}
export interface NotifyHistoryRunActionV1Request {
    notify_history_id: string;
    action_name: string;
    group_id: string;
    v?: NotifyHistoryRunActionV1VEnum;
}
/**
 * NotifyHistoryApi - interface
 *
 * @export
 * @interface NotifyHistoryApiInterface
 */
export interface NotifyHistoryApiInterface {
    /**
     *
     * @summary Get list of my notifications
     * @param {'ru' | 'en' | 'cn'} language Current language
     * @param {'1' | '2' | '3'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {number} [project_id] Project id
     * @param {'high_bitrate' | 'request_access_channel' | 'request_access_project' | 'promocode_test' | 'stream_test' | 'plan_restream_expires' | 'plan_restream_expired' | 'plan_restream_renewed' | 'plan_transcoder_expires' | 'plan_transcoder_expired' | 'plan_transcoder_renewed' | 'plan_storage_expires' | 'plan_storage_expired' | 'plan_storage_renewed' | 'broadcast_unsupported_codec' | 'broadcast_unsupported_codec_screen' | 'broadcast_bitrate_exceeded_screen' | 'rtmp_connect_old_server_screen' | 'broadcast_not_audio' | 'broadcast_bitrate_exceeded' | 'broadcast_started' | 'broadcast_stopped' | 'restream_check_twitch_bitrate_1' | 'api_pause_start' | 'api_pause_end' | 'api_wait_edit' | 'api_restream_start' | 'api_restream_stop' | 'api_drop_broadcast' | 'api_drop_broadcast_remove_company' | 'api_drop_broadcast_update_key' | 'publisher_disconnected' | 'publisher_connected' | 'publisher_initializing' | 'publisher_close' | 'broadcast_connected_start' | 'broadcast_connected_end' | 'broadcast_connecting_stream' | 'broadcast_started_new_stream' | 'broadcast_connecting_lost' | 'broadcast_video_lost_start' | 'broadcast_video_lost_end' | 'broadcast_video_pause_start' | 'broadcast_video_pause_end' | 'broadcast_init_restream' | 'start_stream' | 'create_reader' | 'start_channel' | 'stop_channel' | 'stop_stream_video_timeout' | 'stop_stream_no_start_video' | 'stop_stream' | 'delete_reader' | 'transcoder_start' | 'transcoder_stop' | 'start_channel_failed' | 'start_channel_success' | 'api_channel_initializing_start' | 'api_channel_initializing_failed' | 'api_channel_initializing_success' | 'channel_api_update_settings_success' | 'channel_api_update_settings_error' | 'channel_api_update_playlist_success' | 'channel_api_update_playlist_error' | 'channel_api_update_chat_error' | 'channel_api_stream_key_success' | 'channel_api_stream_key_error' | 'channel_api_auto_stop_disable_success' | 'channel_api_auto_stop_disable_error' | 'channel_api_unbinding_stream_key_error' | 'channel_api_create_broadcast_success' | 'channel_api_create_broadcast_error' | 'channel_api_set_planned_success' | 'channel_api_set_planned_error' | 'channel_api_set_thumbnail_success' | 'channel_api_set_thumbnail_error' | 'channel_token_error' | 'channel_api_group_failed' | 'no_audio_reader' | 'restream_check_twitch_bitrate_2' | 'transcoder_support_error_screen' | 'transcoder_tariff_end_screen' | 'transcoder_count_flow_screen' | 'transcoder_resolution_screen' | 'stream_key_banned' | 'broadcast_change_codec' | 'broadcast_change_region' | 'video_upload_error' | 'stop_channel_error' | 'broadcast_user_action_stop'} [name] Name
     * @param {'telegram' | 'cabinet' | 'mobile'} [channel] Channel
     * @param {Date} [date_from] Date from
     * @param {Date} [date_to] Date to
     * @param {'unread' | 'read'} [status_read] Status read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryGetListMyV1Raw(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedResponseOfNotifyHistorySiteResponse>>;
    /**
     * Get list of my notifications
     */
    notifyHistoryGetListMyV1(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedResponseOfNotifyHistorySiteResponse>;
    /**
     *
     * @summary Get my status unread message for user
     * @param {'ru' | 'en' | 'cn'} language Current language
     * @param {'1' | '2' | '3'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryGetStatusMyV1Raw(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistoryStatusUserResponse>>;
    /**
     * Get my status unread message for user
     */
    notifyHistoryGetStatusMyV1(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistoryStatusUserResponse>;
    /**
     *
     * @summary Get my NotifyHistory item by id
     * @param {string} _id Id of page in mongodb
     * @param {'1'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryGetV1Raw(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>>;
    /**
     * Get my NotifyHistory item by id
     */
    notifyHistoryGetV1(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse>;
    /**
     *
     * @summary Set notification in cabinet as read
     * @param {'ru' | 'en' | 'cn'} language Current language
     * @param {SiteMarkReadHistoryRequest} SiteMarkReadHistoryRequest
     * @param {'1' | '2' | '3'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryMarkOfReadV1Raw(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteMarkReadHistoryResponse>>;
    /**
     * Set notification in cabinet as read
     */
    notifyHistoryMarkOfReadV1(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteMarkReadHistoryResponse>;
    /**
     *
     * @summary Run action in my notify item
     * @param {string} notify_history_id Id of page in mongodb
     * @param {string} action_name Action name
     * @param {string} group_id Group id
     * @param {'1'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryRunActionV1Raw(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>>;
    /**
     * Run action in my notify item
     */
    notifyHistoryRunActionV1(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse>;
    /**
     *
     * @summary Set all notification in cabinet as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistorySetAllCabinetReadV1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponse>>;
    /**
     * Set all notification in cabinet as read
     */
    notifyHistorySetAllCabinetReadV1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponse>;
}
/**
 *
 */
export declare class NotifyHistoryApi extends runtime.BaseAPI implements NotifyHistoryApiInterface {
    /**
     * Get list of my notifications
     */
    notifyHistoryGetListMyV1Raw(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedResponseOfNotifyHistorySiteResponse>>;
    /**
     * Get list of my notifications
     */
    notifyHistoryGetListMyV1(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedResponseOfNotifyHistorySiteResponse>;
    /**
     * Get my status unread message for user
     */
    notifyHistoryGetStatusMyV1Raw(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistoryStatusUserResponse>>;
    /**
     * Get my status unread message for user
     */
    notifyHistoryGetStatusMyV1(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistoryStatusUserResponse>;
    /**
     * Get my NotifyHistory item by id
     */
    notifyHistoryGetV1Raw(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>>;
    /**
     * Get my NotifyHistory item by id
     */
    notifyHistoryGetV1(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse>;
    /**
     * Set notification in cabinet as read
     */
    notifyHistoryMarkOfReadV1Raw(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteMarkReadHistoryResponse>>;
    /**
     * Set notification in cabinet as read
     */
    notifyHistoryMarkOfReadV1(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteMarkReadHistoryResponse>;
    /**
     * Run action in my notify item
     */
    notifyHistoryRunActionV1Raw(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>>;
    /**
     * Run action in my notify item
     */
    notifyHistoryRunActionV1(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse>;
    /**
     * Set all notification in cabinet as read
     */
    notifyHistorySetAllCabinetReadV1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponse>>;
    /**
     * Set all notification in cabinet as read
     */
    notifyHistorySetAllCabinetReadV1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponse>;
}
/**
 * @export
 */
export declare const NotifyHistoryGetListMyV1LanguageEnum: {
    readonly ru: "ru";
    readonly en: "en";
    readonly cn: "cn";
};
export type NotifyHistoryGetListMyV1LanguageEnum = typeof NotifyHistoryGetListMyV1LanguageEnum[keyof typeof NotifyHistoryGetListMyV1LanguageEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetListMyV1VEnum: {
    readonly _1: "1";
    readonly _2: "2";
    readonly _3: "3";
};
export type NotifyHistoryGetListMyV1VEnum = typeof NotifyHistoryGetListMyV1VEnum[keyof typeof NotifyHistoryGetListMyV1VEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetListMyV1NameEnum: {
    readonly high_bitrate: "high_bitrate";
    readonly request_access_channel: "request_access_channel";
    readonly request_access_project: "request_access_project";
    readonly promocode_test: "promocode_test";
    readonly stream_test: "stream_test";
    readonly plan_restream_expires: "plan_restream_expires";
    readonly plan_restream_expired: "plan_restream_expired";
    readonly plan_restream_renewed: "plan_restream_renewed";
    readonly plan_transcoder_expires: "plan_transcoder_expires";
    readonly plan_transcoder_expired: "plan_transcoder_expired";
    readonly plan_transcoder_renewed: "plan_transcoder_renewed";
    readonly plan_storage_expires: "plan_storage_expires";
    readonly plan_storage_expired: "plan_storage_expired";
    readonly plan_storage_renewed: "plan_storage_renewed";
    readonly broadcast_unsupported_codec: "broadcast_unsupported_codec";
    readonly broadcast_unsupported_codec_screen: "broadcast_unsupported_codec_screen";
    readonly broadcast_bitrate_exceeded_screen: "broadcast_bitrate_exceeded_screen";
    readonly rtmp_connect_old_server_screen: "rtmp_connect_old_server_screen";
    readonly broadcast_not_audio: "broadcast_not_audio";
    readonly broadcast_bitrate_exceeded: "broadcast_bitrate_exceeded";
    readonly broadcast_started: "broadcast_started";
    readonly broadcast_stopped: "broadcast_stopped";
    readonly restream_check_twitch_bitrate_1: "restream_check_twitch_bitrate_1";
    readonly api_pause_start: "api_pause_start";
    readonly api_pause_end: "api_pause_end";
    readonly api_wait_edit: "api_wait_edit";
    readonly api_restream_start: "api_restream_start";
    readonly api_restream_stop: "api_restream_stop";
    readonly api_drop_broadcast: "api_drop_broadcast";
    readonly api_drop_broadcast_remove_company: "api_drop_broadcast_remove_company";
    readonly api_drop_broadcast_update_key: "api_drop_broadcast_update_key";
    readonly publisher_disconnected: "publisher_disconnected";
    readonly publisher_connected: "publisher_connected";
    readonly publisher_initializing: "publisher_initializing";
    readonly publisher_close: "publisher_close";
    readonly broadcast_connected_start: "broadcast_connected_start";
    readonly broadcast_connected_end: "broadcast_connected_end";
    readonly broadcast_connecting_stream: "broadcast_connecting_stream";
    readonly broadcast_started_new_stream: "broadcast_started_new_stream";
    readonly broadcast_connecting_lost: "broadcast_connecting_lost";
    readonly broadcast_video_lost_start: "broadcast_video_lost_start";
    readonly broadcast_video_lost_end: "broadcast_video_lost_end";
    readonly broadcast_video_pause_start: "broadcast_video_pause_start";
    readonly broadcast_video_pause_end: "broadcast_video_pause_end";
    readonly broadcast_init_restream: "broadcast_init_restream";
    readonly start_stream: "start_stream";
    readonly create_reader: "create_reader";
    readonly start_channel: "start_channel";
    readonly stop_channel: "stop_channel";
    readonly stop_stream_video_timeout: "stop_stream_video_timeout";
    readonly stop_stream_no_start_video: "stop_stream_no_start_video";
    readonly stop_stream: "stop_stream";
    readonly delete_reader: "delete_reader";
    readonly transcoder_start: "transcoder_start";
    readonly transcoder_stop: "transcoder_stop";
    readonly start_channel_failed: "start_channel_failed";
    readonly start_channel_success: "start_channel_success";
    readonly api_channel_initializing_start: "api_channel_initializing_start";
    readonly api_channel_initializing_failed: "api_channel_initializing_failed";
    readonly api_channel_initializing_success: "api_channel_initializing_success";
    readonly channel_api_update_settings_success: "channel_api_update_settings_success";
    readonly channel_api_update_settings_error: "channel_api_update_settings_error";
    readonly channel_api_update_playlist_success: "channel_api_update_playlist_success";
    readonly channel_api_update_playlist_error: "channel_api_update_playlist_error";
    readonly channel_api_update_chat_error: "channel_api_update_chat_error";
    readonly channel_api_stream_key_success: "channel_api_stream_key_success";
    readonly channel_api_stream_key_error: "channel_api_stream_key_error";
    readonly channel_api_auto_stop_disable_success: "channel_api_auto_stop_disable_success";
    readonly channel_api_auto_stop_disable_error: "channel_api_auto_stop_disable_error";
    readonly channel_api_unbinding_stream_key_error: "channel_api_unbinding_stream_key_error";
    readonly channel_api_create_broadcast_success: "channel_api_create_broadcast_success";
    readonly channel_api_create_broadcast_error: "channel_api_create_broadcast_error";
    readonly channel_api_set_planned_success: "channel_api_set_planned_success";
    readonly channel_api_set_planned_error: "channel_api_set_planned_error";
    readonly channel_api_set_thumbnail_success: "channel_api_set_thumbnail_success";
    readonly channel_api_set_thumbnail_error: "channel_api_set_thumbnail_error";
    readonly channel_token_error: "channel_token_error";
    readonly channel_api_group_failed: "channel_api_group_failed";
    readonly no_audio_reader: "no_audio_reader";
    readonly restream_check_twitch_bitrate_2: "restream_check_twitch_bitrate_2";
    readonly transcoder_support_error_screen: "transcoder_support_error_screen";
    readonly transcoder_tariff_end_screen: "transcoder_tariff_end_screen";
    readonly transcoder_count_flow_screen: "transcoder_count_flow_screen";
    readonly transcoder_resolution_screen: "transcoder_resolution_screen";
    readonly stream_key_banned: "stream_key_banned";
    readonly broadcast_change_codec: "broadcast_change_codec";
    readonly broadcast_change_region: "broadcast_change_region";
    readonly video_upload_error: "video_upload_error";
    readonly stop_channel_error: "stop_channel_error";
    readonly broadcast_user_action_stop: "broadcast_user_action_stop";
};
export type NotifyHistoryGetListMyV1NameEnum = typeof NotifyHistoryGetListMyV1NameEnum[keyof typeof NotifyHistoryGetListMyV1NameEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetListMyV1ChannelEnum: {
    readonly telegram: "telegram";
    readonly cabinet: "cabinet";
    readonly mobile: "mobile";
};
export type NotifyHistoryGetListMyV1ChannelEnum = typeof NotifyHistoryGetListMyV1ChannelEnum[keyof typeof NotifyHistoryGetListMyV1ChannelEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetListMyV1StatusReadEnum: {
    readonly unread: "unread";
    readonly read: "read";
};
export type NotifyHistoryGetListMyV1StatusReadEnum = typeof NotifyHistoryGetListMyV1StatusReadEnum[keyof typeof NotifyHistoryGetListMyV1StatusReadEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetStatusMyV1LanguageEnum: {
    readonly ru: "ru";
    readonly en: "en";
    readonly cn: "cn";
};
export type NotifyHistoryGetStatusMyV1LanguageEnum = typeof NotifyHistoryGetStatusMyV1LanguageEnum[keyof typeof NotifyHistoryGetStatusMyV1LanguageEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetStatusMyV1VEnum: {
    readonly _1: "1";
    readonly _2: "2";
    readonly _3: "3";
};
export type NotifyHistoryGetStatusMyV1VEnum = typeof NotifyHistoryGetStatusMyV1VEnum[keyof typeof NotifyHistoryGetStatusMyV1VEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetV1VEnum: {
    readonly _1: "1";
};
export type NotifyHistoryGetV1VEnum = typeof NotifyHistoryGetV1VEnum[keyof typeof NotifyHistoryGetV1VEnum];
/**
 * @export
 */
export declare const NotifyHistoryMarkOfReadV1LanguageEnum: {
    readonly ru: "ru";
    readonly en: "en";
    readonly cn: "cn";
};
export type NotifyHistoryMarkOfReadV1LanguageEnum = typeof NotifyHistoryMarkOfReadV1LanguageEnum[keyof typeof NotifyHistoryMarkOfReadV1LanguageEnum];
/**
 * @export
 */
export declare const NotifyHistoryMarkOfReadV1VEnum: {
    readonly _1: "1";
    readonly _2: "2";
    readonly _3: "3";
};
export type NotifyHistoryMarkOfReadV1VEnum = typeof NotifyHistoryMarkOfReadV1VEnum[keyof typeof NotifyHistoryMarkOfReadV1VEnum];
/**
 * @export
 */
export declare const NotifyHistoryRunActionV1VEnum: {
    readonly _1: "1";
};
export type NotifyHistoryRunActionV1VEnum = typeof NotifyHistoryRunActionV1VEnum[keyof typeof NotifyHistoryRunActionV1VEnum];
//# sourceMappingURL=NotifyHistoryApi.d.ts.map