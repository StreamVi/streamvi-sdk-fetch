/**
 * StreamVi Backend
 * API
 *
 * The version of the OpenAPI document: 3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import * as runtime from '../runtime';
import type { NotifyHistorySiteResponse, NotifyHistoryStatusUserResponse, PaginatedResponseOfNotifyHistorySiteResponse, SiteMarkReadHistoryRequest, SiteMarkReadHistoryResponse, SuccessResponse } from '../models/index';
export interface NotifyHistoryGetListMyV1Request {
    language: NotifyHistoryGetListMyV1LanguageEnum;
    v?: NotifyHistoryGetListMyV1VEnum;
    limit?: number;
    offset?: number;
    projectId?: number;
    name?: NotifyHistoryGetListMyV1NameEnum;
    channel?: NotifyHistoryGetListMyV1ChannelEnum;
    dateFrom?: Date;
    dateTo?: Date;
    statusRead?: NotifyHistoryGetListMyV1StatusReadEnum;
}
export interface NotifyHistoryGetStatusMyV1Request {
    language: NotifyHistoryGetStatusMyV1LanguageEnum;
    v?: NotifyHistoryGetStatusMyV1VEnum;
}
export interface NotifyHistoryGetV1Request {
    id: string;
    v?: NotifyHistoryGetV1VEnum;
}
export interface NotifyHistoryMarkOfReadV1Request {
    language: NotifyHistoryMarkOfReadV1LanguageEnum;
    siteMarkReadHistoryRequest: SiteMarkReadHistoryRequest;
    v?: NotifyHistoryMarkOfReadV1VEnum;
}
export interface NotifyHistoryRunActionV1Request {
    notifyHistoryId: string;
    actionName: string;
    groupId: string;
    v?: NotifyHistoryRunActionV1VEnum;
}
/**
 * NotifyHistoryApi - interface
 *
 * @export
 * @interface NotifyHistoryApiInterface
 */
export interface NotifyHistoryApiInterface {
    /**
     *
     * @summary Get list of my notifications
     * @param {'ru' | 'en' | 'cn'} language Current language
     * @param {'1' | '2' | '3'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {number} [limit] Number of results
     * @param {number} [offset] Page offset number
     * @param {number} [projectId] Project id
     * @param {'high_bitrate' | 'request_access_channel' | 'request_access_project' | 'promocode_test' | 'stream_test' | 'plan_restream_expires' | 'plan_restream_expired' | 'plan_restream_renewed' | 'plan_transcoder_expires' | 'plan_transcoder_expired' | 'plan_transcoder_renewed' | 'plan_storage_expires' | 'plan_storage_expired' | 'plan_storage_renewed' | 'broadcast_unsupported_codec' | 'broadcast_unsupported_codec_screen' | 'broadcast_bitrate_exceeded_screen' | 'rtmp_connect_old_server_screen' | 'broadcast_not_audio' | 'broadcast_bitrate_exceeded' | 'broadcast_started' | 'broadcast_stopped' | 'restream_check_twitch_bitrate_1' | 'api_pause_start' | 'api_pause_end' | 'api_wait_edit' | 'api_restream_start' | 'api_restream_stop' | 'api_drop_broadcast' | 'api_drop_broadcast_remove_company' | 'api_drop_broadcast_update_key' | 'publisher_disconnected' | 'publisher_connected' | 'publisher_initializing' | 'publisher_close' | 'broadcast_connected_start' | 'broadcast_connected_end' | 'broadcast_connecting_stream' | 'broadcast_started_new_stream' | 'broadcast_connecting_lost' | 'broadcast_video_lost_start' | 'broadcast_video_lost_end' | 'broadcast_video_pause_start' | 'broadcast_video_pause_end' | 'broadcast_init_restream' | 'start_stream' | 'create_reader' | 'start_channel' | 'stop_channel' | 'stop_stream_video_timeout' | 'stop_stream_no_start_video' | 'stop_stream' | 'delete_reader' | 'transcoder_start' | 'transcoder_stop' | 'start_channel_failed' | 'start_channel_success' | 'api_channel_initializing_start' | 'api_channel_initializing_failed' | 'api_channel_initializing_success' | 'channel_api_update_settings_success' | 'channel_api_update_settings_error' | 'channel_api_update_playlist_success' | 'channel_api_update_playlist_error' | 'channel_api_update_chat_error' | 'channel_api_stream_key_success' | 'channel_api_stream_key_error' | 'channel_api_auto_stop_disable_success' | 'channel_api_auto_stop_disable_error' | 'channel_api_unbinding_stream_key_error' | 'channel_api_create_broadcast_success' | 'channel_api_create_broadcast_error' | 'channel_api_set_planned_success' | 'channel_api_set_planned_error' | 'channel_api_set_thumbnail_success' | 'channel_api_set_thumbnail_error' | 'channel_token_error' | 'channel_api_group_failed' | 'no_audio_reader' | 'restream_check_twitch_bitrate_2' | 'transcoder_support_error_screen' | 'transcoder_tariff_end_screen' | 'transcoder_count_flow_screen' | 'transcoder_resolution_screen' | 'stream_key_banned' | 'broadcast_change_codec' | 'broadcast_change_region' | 'video_upload_error' | 'stop_channel_error' | 'broadcast_user_action_stop'} [name] Name
     * @param {'telegram' | 'cabinet' | 'mobile'} [channel] Channel
     * @param {Date} [dateFrom] Date from
     * @param {Date} [dateTo] Date to
     * @param {'unread' | 'read'} [statusRead] Status read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryGetListMyV1Raw(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedResponseOfNotifyHistorySiteResponse>>;
    /**
     * Get list of my notifications
     */
    notifyHistoryGetListMyV1(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedResponseOfNotifyHistorySiteResponse>;
    /**
     *
     * @summary Get my status unread message for user
     * @param {'ru' | 'en' | 'cn'} language Current language
     * @param {'1' | '2' | '3'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryGetStatusMyV1Raw(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistoryStatusUserResponse>>;
    /**
     * Get my status unread message for user
     */
    notifyHistoryGetStatusMyV1(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistoryStatusUserResponse>;
    /**
     *
     * @summary Get my NotifyHistory item by id
     * @param {string} id Id of page in mongodb
     * @param {'1'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryGetV1Raw(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>>;
    /**
     * Get my NotifyHistory item by id
     */
    notifyHistoryGetV1(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse>;
    /**
     *
     * @summary Set notification in cabinet as read
     * @param {'ru' | 'en' | 'cn'} language Current language
     * @param {SiteMarkReadHistoryRequest} siteMarkReadHistoryRequest
     * @param {'1' | '2' | '3'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryMarkOfReadV1Raw(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteMarkReadHistoryResponse>>;
    /**
     * Set notification in cabinet as read
     */
    notifyHistoryMarkOfReadV1(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteMarkReadHistoryResponse>;
    /**
     *
     * @summary Run action in my notify item
     * @param {string} notifyHistoryId Id of page in mongodb
     * @param {string} actionName Action name
     * @param {string} groupId Group id
     * @param {'1'} [v] Version (automatically defaults to 1 based on method version, can be overridden)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistoryRunActionV1Raw(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>>;
    /**
     * Run action in my notify item
     */
    notifyHistoryRunActionV1(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse>;
    /**
     *
     * @summary Set all notification in cabinet as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyHistoryApiInterface
     */
    notifyHistorySetAllCabinetReadV1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponse>>;
    /**
     * Set all notification in cabinet as read
     */
    notifyHistorySetAllCabinetReadV1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponse>;
}
/**
 *
 */
export declare class NotifyHistoryApi extends runtime.BaseAPI implements NotifyHistoryApiInterface {
    /**
     * Get list of my notifications
     */
    notifyHistoryGetListMyV1Raw(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedResponseOfNotifyHistorySiteResponse>>;
    /**
     * Get list of my notifications
     */
    notifyHistoryGetListMyV1(requestParameters: NotifyHistoryGetListMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedResponseOfNotifyHistorySiteResponse>;
    /**
     * Get my status unread message for user
     */
    notifyHistoryGetStatusMyV1Raw(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistoryStatusUserResponse>>;
    /**
     * Get my status unread message for user
     */
    notifyHistoryGetStatusMyV1(requestParameters: NotifyHistoryGetStatusMyV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistoryStatusUserResponse>;
    /**
     * Get my NotifyHistory item by id
     */
    notifyHistoryGetV1Raw(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>>;
    /**
     * Get my NotifyHistory item by id
     */
    notifyHistoryGetV1(requestParameters: NotifyHistoryGetV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse>;
    /**
     * Set notification in cabinet as read
     */
    notifyHistoryMarkOfReadV1Raw(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteMarkReadHistoryResponse>>;
    /**
     * Set notification in cabinet as read
     */
    notifyHistoryMarkOfReadV1(requestParameters: NotifyHistoryMarkOfReadV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteMarkReadHistoryResponse>;
    /**
     * Run action in my notify item
     */
    notifyHistoryRunActionV1Raw(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotifyHistorySiteResponse>>;
    /**
     * Run action in my notify item
     */
    notifyHistoryRunActionV1(requestParameters: NotifyHistoryRunActionV1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotifyHistorySiteResponse>;
    /**
     * Set all notification in cabinet as read
     */
    notifyHistorySetAllCabinetReadV1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponse>>;
    /**
     * Set all notification in cabinet as read
     */
    notifyHistorySetAllCabinetReadV1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponse>;
}
/**
 * @export
 */
export declare const NotifyHistoryGetListMyV1LanguageEnum: {
    readonly Ru: "ru";
    readonly En: "en";
    readonly Cn: "cn";
};
export type NotifyHistoryGetListMyV1LanguageEnum = typeof NotifyHistoryGetListMyV1LanguageEnum[keyof typeof NotifyHistoryGetListMyV1LanguageEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetListMyV1VEnum: {
    readonly _1: "1";
    readonly _2: "2";
    readonly _3: "3";
};
export type NotifyHistoryGetListMyV1VEnum = typeof NotifyHistoryGetListMyV1VEnum[keyof typeof NotifyHistoryGetListMyV1VEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetListMyV1NameEnum: {
    readonly HighBitrate: "high_bitrate";
    readonly RequestAccessChannel: "request_access_channel";
    readonly RequestAccessProject: "request_access_project";
    readonly PromocodeTest: "promocode_test";
    readonly StreamTest: "stream_test";
    readonly PlanRestreamExpires: "plan_restream_expires";
    readonly PlanRestreamExpired: "plan_restream_expired";
    readonly PlanRestreamRenewed: "plan_restream_renewed";
    readonly PlanTranscoderExpires: "plan_transcoder_expires";
    readonly PlanTranscoderExpired: "plan_transcoder_expired";
    readonly PlanTranscoderRenewed: "plan_transcoder_renewed";
    readonly PlanStorageExpires: "plan_storage_expires";
    readonly PlanStorageExpired: "plan_storage_expired";
    readonly PlanStorageRenewed: "plan_storage_renewed";
    readonly BroadcastUnsupportedCodec: "broadcast_unsupported_codec";
    readonly BroadcastUnsupportedCodecScreen: "broadcast_unsupported_codec_screen";
    readonly BroadcastBitrateExceededScreen: "broadcast_bitrate_exceeded_screen";
    readonly RtmpConnectOldServerScreen: "rtmp_connect_old_server_screen";
    readonly BroadcastNotAudio: "broadcast_not_audio";
    readonly BroadcastBitrateExceeded: "broadcast_bitrate_exceeded";
    readonly BroadcastStarted: "broadcast_started";
    readonly BroadcastStopped: "broadcast_stopped";
    readonly RestreamCheckTwitchBitrate1: "restream_check_twitch_bitrate_1";
    readonly ApiPauseStart: "api_pause_start";
    readonly ApiPauseEnd: "api_pause_end";
    readonly ApiWaitEdit: "api_wait_edit";
    readonly ApiRestreamStart: "api_restream_start";
    readonly ApiRestreamStop: "api_restream_stop";
    readonly ApiDropBroadcast: "api_drop_broadcast";
    readonly ApiDropBroadcastRemoveCompany: "api_drop_broadcast_remove_company";
    readonly ApiDropBroadcastUpdateKey: "api_drop_broadcast_update_key";
    readonly PublisherDisconnected: "publisher_disconnected";
    readonly PublisherConnected: "publisher_connected";
    readonly PublisherInitializing: "publisher_initializing";
    readonly PublisherClose: "publisher_close";
    readonly BroadcastConnectedStart: "broadcast_connected_start";
    readonly BroadcastConnectedEnd: "broadcast_connected_end";
    readonly BroadcastConnectingStream: "broadcast_connecting_stream";
    readonly BroadcastStartedNewStream: "broadcast_started_new_stream";
    readonly BroadcastConnectingLost: "broadcast_connecting_lost";
    readonly BroadcastVideoLostStart: "broadcast_video_lost_start";
    readonly BroadcastVideoLostEnd: "broadcast_video_lost_end";
    readonly BroadcastVideoPauseStart: "broadcast_video_pause_start";
    readonly BroadcastVideoPauseEnd: "broadcast_video_pause_end";
    readonly BroadcastInitRestream: "broadcast_init_restream";
    readonly StartStream: "start_stream";
    readonly CreateReader: "create_reader";
    readonly StartChannel: "start_channel";
    readonly StopChannel: "stop_channel";
    readonly StopStreamVideoTimeout: "stop_stream_video_timeout";
    readonly StopStreamNoStartVideo: "stop_stream_no_start_video";
    readonly StopStream: "stop_stream";
    readonly DeleteReader: "delete_reader";
    readonly TranscoderStart: "transcoder_start";
    readonly TranscoderStop: "transcoder_stop";
    readonly StartChannelFailed: "start_channel_failed";
    readonly StartChannelSuccess: "start_channel_success";
    readonly ApiChannelInitializingStart: "api_channel_initializing_start";
    readonly ApiChannelInitializingFailed: "api_channel_initializing_failed";
    readonly ApiChannelInitializingSuccess: "api_channel_initializing_success";
    readonly ChannelApiUpdateSettingsSuccess: "channel_api_update_settings_success";
    readonly ChannelApiUpdateSettingsError: "channel_api_update_settings_error";
    readonly ChannelApiUpdatePlaylistSuccess: "channel_api_update_playlist_success";
    readonly ChannelApiUpdatePlaylistError: "channel_api_update_playlist_error";
    readonly ChannelApiUpdateChatError: "channel_api_update_chat_error";
    readonly ChannelApiStreamKeySuccess: "channel_api_stream_key_success";
    readonly ChannelApiStreamKeyError: "channel_api_stream_key_error";
    readonly ChannelApiAutoStopDisableSuccess: "channel_api_auto_stop_disable_success";
    readonly ChannelApiAutoStopDisableError: "channel_api_auto_stop_disable_error";
    readonly ChannelApiUnbindingStreamKeyError: "channel_api_unbinding_stream_key_error";
    readonly ChannelApiCreateBroadcastSuccess: "channel_api_create_broadcast_success";
    readonly ChannelApiCreateBroadcastError: "channel_api_create_broadcast_error";
    readonly ChannelApiSetPlannedSuccess: "channel_api_set_planned_success";
    readonly ChannelApiSetPlannedError: "channel_api_set_planned_error";
    readonly ChannelApiSetThumbnailSuccess: "channel_api_set_thumbnail_success";
    readonly ChannelApiSetThumbnailError: "channel_api_set_thumbnail_error";
    readonly ChannelTokenError: "channel_token_error";
    readonly ChannelApiGroupFailed: "channel_api_group_failed";
    readonly NoAudioReader: "no_audio_reader";
    readonly RestreamCheckTwitchBitrate2: "restream_check_twitch_bitrate_2";
    readonly TranscoderSupportErrorScreen: "transcoder_support_error_screen";
    readonly TranscoderTariffEndScreen: "transcoder_tariff_end_screen";
    readonly TranscoderCountFlowScreen: "transcoder_count_flow_screen";
    readonly TranscoderResolutionScreen: "transcoder_resolution_screen";
    readonly StreamKeyBanned: "stream_key_banned";
    readonly BroadcastChangeCodec: "broadcast_change_codec";
    readonly BroadcastChangeRegion: "broadcast_change_region";
    readonly VideoUploadError: "video_upload_error";
    readonly StopChannelError: "stop_channel_error";
    readonly BroadcastUserActionStop: "broadcast_user_action_stop";
};
export type NotifyHistoryGetListMyV1NameEnum = typeof NotifyHistoryGetListMyV1NameEnum[keyof typeof NotifyHistoryGetListMyV1NameEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetListMyV1ChannelEnum: {
    readonly Telegram: "telegram";
    readonly Cabinet: "cabinet";
    readonly Mobile: "mobile";
};
export type NotifyHistoryGetListMyV1ChannelEnum = typeof NotifyHistoryGetListMyV1ChannelEnum[keyof typeof NotifyHistoryGetListMyV1ChannelEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetListMyV1StatusReadEnum: {
    readonly Unread: "unread";
    readonly Read: "read";
};
export type NotifyHistoryGetListMyV1StatusReadEnum = typeof NotifyHistoryGetListMyV1StatusReadEnum[keyof typeof NotifyHistoryGetListMyV1StatusReadEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetStatusMyV1LanguageEnum: {
    readonly Ru: "ru";
    readonly En: "en";
    readonly Cn: "cn";
};
export type NotifyHistoryGetStatusMyV1LanguageEnum = typeof NotifyHistoryGetStatusMyV1LanguageEnum[keyof typeof NotifyHistoryGetStatusMyV1LanguageEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetStatusMyV1VEnum: {
    readonly _1: "1";
    readonly _2: "2";
    readonly _3: "3";
};
export type NotifyHistoryGetStatusMyV1VEnum = typeof NotifyHistoryGetStatusMyV1VEnum[keyof typeof NotifyHistoryGetStatusMyV1VEnum];
/**
 * @export
 */
export declare const NotifyHistoryGetV1VEnum: {
    readonly _1: "1";
};
export type NotifyHistoryGetV1VEnum = typeof NotifyHistoryGetV1VEnum[keyof typeof NotifyHistoryGetV1VEnum];
/**
 * @export
 */
export declare const NotifyHistoryMarkOfReadV1LanguageEnum: {
    readonly Ru: "ru";
    readonly En: "en";
    readonly Cn: "cn";
};
export type NotifyHistoryMarkOfReadV1LanguageEnum = typeof NotifyHistoryMarkOfReadV1LanguageEnum[keyof typeof NotifyHistoryMarkOfReadV1LanguageEnum];
/**
 * @export
 */
export declare const NotifyHistoryMarkOfReadV1VEnum: {
    readonly _1: "1";
    readonly _2: "2";
    readonly _3: "3";
};
export type NotifyHistoryMarkOfReadV1VEnum = typeof NotifyHistoryMarkOfReadV1VEnum[keyof typeof NotifyHistoryMarkOfReadV1VEnum];
/**
 * @export
 */
export declare const NotifyHistoryRunActionV1VEnum: {
    readonly _1: "1";
};
export type NotifyHistoryRunActionV1VEnum = typeof NotifyHistoryRunActionV1VEnum[keyof typeof NotifyHistoryRunActionV1VEnum];
//# sourceMappingURL=NotifyHistoryApi.d.ts.map